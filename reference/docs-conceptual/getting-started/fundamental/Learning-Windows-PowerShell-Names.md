---
ms.date: 2017-06-05
keywords: powershell,cmdlet
title: "Windows PowerShell 이름 학습"
ms.assetid: b4d0fd22-8298-4ee6-82ae-9b6f2907c986
ms.openlocfilehash: 28c821c4a617b6ac775dbdda8ade3d15c3f218c3
ms.sourcegitcommit: 74255f0b5f386a072458af058a15240140acb294
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/03/2017
---
# <a name="learning-windows-powershell-names"></a><span data-ttu-id="d0390-103">Windows PowerShell 이름 학습</span><span class="sxs-lookup"><span data-stu-id="d0390-103">Learning Windows PowerShell Names</span></span>
<span data-ttu-id="d0390-104">명령 및 명령 매개 변수의 이름을 학습하려면 대부분의 명령줄 인터페이스에서 상당한 시간이 소요됩니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-104">Learning names of commands and command parameters is a significant time investment with most command-line interfaces.</span></span> <span data-ttu-id="d0390-105">문제는 패턴이 거의 없으므로 정기적으로 사용해야 하는 각 명령과 각 매개 변수를 기억하는 것이 유일한 학습 방법이라는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-105">The issue is that there are very few patterns, so the only way to learn is by memorizing each command and each parameter that you need to use on a regular basis.</span></span>

<span data-ttu-id="d0390-106">새 명령이나 매개 변수로 작업하는 경우 일반적으로 이미 알고 있는 사항을 사용할 수 없으므로 새 이름을 찾아서 학습해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-106">When you work with a new command or parameter, you cannot generally use what you already know; you have to find and learn a new name.</span></span> <span data-ttu-id="d0390-107">인터페이스가 작은 도구 집합에서 점점 기능을 추가하는 방식을 살펴보면 표준 구조가 아닌 이유를 쉽게 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-107">If you look at how interfaces grow from a small set of tools with incremental additions to functionality, it is easy to see why the structure is nonstandard.</span></span> <span data-ttu-id="d0390-108">특히 명령 이름의 경우 각 명령이 개별 도구이므로 논리적인 것 같지만 명령 이름을 처리하는 더 나은 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-108">With command names in particular, this may sound logical since each command is a separate tool, but there is a better way to handle command names.</span></span>

<span data-ttu-id="d0390-109">대부분의 명령은 서비스나 프로세스와 같은 운영 체제 또는 응용 프로그램의 요소를 관리하도록 작성되었습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-109">Most commands are built to manage elements of the operating system or applications, such as services or processes.</span></span> <span data-ttu-id="d0390-110">명령에는 패밀리에 맞거나 맞지 않을 수 있는 다양한 이름이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-110">The commands have a variety of names that may or may not fit into a family.</span></span> <span data-ttu-id="d0390-111">예를 들어 Windows 시스템에서는 **net start** 및 **net stop** 명령을 사용하여 서비스를 시작하고 중지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-111">For example, on Windows systems, you can use the **net start** and **net stop** commands to start and stop a service.</span></span> <span data-ttu-id="d0390-112">**net** 서비스 명령의 명명 패턴에 맞지 않는 **sc**라는 완전히 다른 이름을 가진 보다 일반화된 다른 Windows용 서비스 제어 도구도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-112">There is another more generalized service control tool for Windows that has a completely different name, **sc**, that does not fit into the naming pattern for the **net** service commands.</span></span> <span data-ttu-id="d0390-113">프로세스 관리의 경우 Windows에는 프로세스를 표시하는 **tasklist** 명령과 프로세스를 중단하는 **taskkill** 명령이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-113">For process management, Windows has the **tasklist** command to list processes and the **taskkill** command to kill processes.</span></span>

<span data-ttu-id="d0390-114">매개 변수를 사용하는 명령에는 불규칙한 매개 변수 사양이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-114">Commands that take parameters have irregular parameter specifications.</span></span> <span data-ttu-id="d0390-115">**net start** 명령을 사용하여 원격 컴퓨터에서 서비스를 시작할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-115">You cannot use the **net start** command to start a service on a remote computer.</span></span> <span data-ttu-id="d0390-116">**sc** 명령은 원격 컴퓨터에서 서비스를 시작하지만 원격 컴퓨터를 지정하기 위해 해당 이름 앞에 이중 백슬래시를 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-116">The **sc** command will start a service on a remote computer, but to specify the remote computer, you must prefix its name with a double backslash.</span></span> <span data-ttu-id="d0390-117">예를 들어 DC01이라는 원격 컴퓨터에서 스풀러 서비스를 시작하려면 **sc \\\\DC01 start spooler**를 입력합니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-117">For example, to start the spooler service on a remote computer named DC01, you would type **sc \\\\DC01 start spooler**.</span></span> <span data-ttu-id="d0390-118">DC01에서 실행 중인 작업을 표시하려면 **tasklist /S DC01**과 같이 **/S**("system") 매개 변수를 사용하고 백슬래시 없이 DC01 이름을 입력해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-118">To list tasks running on DC01, you need to use the **/S** (for "system") parameter and supply the name DC01 without backslashes, like this: **tasklist /S DC01**.</span></span>

<span data-ttu-id="d0390-119">서비스와 프로세스 간에는 중요한 기술적 차이가 있지만 둘 다 잘 정의된 수명 주기를 가진 컴퓨터 관리 가능 요소의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-119">Although there are important technical distinctions between a service and a process, they are both examples of manageable elements on a computer that have a well-defined life cycle.</span></span> <span data-ttu-id="d0390-120">서비스나 프로세스를 시작 또는 중지하거나, 현재 실행 중인 모든 서비스나 프로세스의 목록을 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-120">You may want to start or stop a service or process, or get a list of all currently running services or processes.</span></span> <span data-ttu-id="d0390-121">즉, 서비스와 프로세스는 서로 다르지만 서비스나 프로세스에서 수행하는 작업은 개념적으로 동일한 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-121">In other words, although a service and a process are different things, the actions we perform on a service or a process are often conceptually the same.</span></span> <span data-ttu-id="d0390-122">또한 매개 변수를 지정하여 작업을 사용자 지정하기 위해 선택할 수 있는 사항도 개념적으로 유사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-122">Furthermore, choices we may make to customize an action by specifying parameters may be conceptually similar as well.</span></span>

<span data-ttu-id="d0390-123">Windows PowerShell은 이러한 유사성을 이용하여 cmdlet을 이해하고 사용하기 위해 알아야 하는 고유 이름 수를 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-123">Windows PowerShell exploits these similarities to reduce the number of distinct names you need to know to understand and use cmdlets.</span></span>

### <a name="cmdlets-use-verb-noun-names-to-reduce-command-memorization"></a><span data-ttu-id="d0390-124">쉽게 기억할 수 있는 Cmdlet에 동사-명사 이름 사용</span><span class="sxs-lookup"><span data-stu-id="d0390-124">Cmdlets Use Verb-Noun Names to Reduce Command Memorization</span></span>
<span data-ttu-id="d0390-125">Windows PowerShell은 각 cmdlet 이름이 표준 동사와 특정 명사를 하이픈으로 연결하여 구성되는 "동사-명사" 명명 시스템을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-125">Windows PowerShell uses a "verb-noun" naming system, where each cmdlet name consists of a standard verb hyphenated with a specific noun.</span></span> <span data-ttu-id="d0390-126">Windows PowerShell 동사는 영어 동사가 아닐 수도 있지만 Windows PowerShell에서 특정 작업을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-126">Windows PowerShell verbs are not always English verbs, but they express specific actions in Windows PowerShell.</span></span> <span data-ttu-id="d0390-127">명사는 모든 언어의 명사와 매우 비슷하며, 시스템 관리에서 중요한 특정 유형의 개체를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-127">Nouns are very much like nouns in any language, they describe specific types of objects that are important in system administration.</span></span> <span data-ttu-id="d0390-128">동사와 명사의 몇 가지 예를 살펴보면 두 부분으로 이루어진 이러한 이름이 학습에 어떻게 도움이 되는지를 쉽게 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-128">It is easy to demonstrate how these two-part names reduce learning effort by looking at a few examples of verbs and nouns.</span></span>

<span data-ttu-id="d0390-129">명사는 덜 제한적이지만 항상 명령의 실행 대상을 나타내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-129">Nouns are less restricted, but they should always describe what a command acts upon.</span></span> <span data-ttu-id="d0390-130">Windows PowerShell에는 **Get-Process**, **Stop-Process**, **Get-Service**, **Stop-Service** 등의 명령이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-130">Windows PowerShell has commands such as **Get-Process**, **Stop-Process**, **Get-Service**, and **Stop-Service**.</span></span>

<span data-ttu-id="d0390-131">명사 2개와 동사 2개를 사용하는 경우 일관성을 유지해도 학습이 크게 간소화되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-131">In the case of two nouns and two verbs, consistency does not simplify learning that much.</span></span> <span data-ttu-id="d0390-132">그러나 동사 10개와 명사 10개의 표준 집합을 살펴보면 20개의 단어만 이해해도 해당 단어를 사용하여 100개의 고유한 명령 이름을 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-132">However, if you look at a standard set of 10 verbs and 10 nouns, you then have only 20 words to understand, but those words can be used to form 100 distinct command names.</span></span>

<span data-ttu-id="d0390-133">이름을 통해 명령이 수행하는 작업을 인식할 수 있는 경우가 많으며, 일반적으로 새 명령에 어떤 이름을 사용해야 하는지가 명확합니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-133">Frequently, you can recognize what a command does by reading its name, and it is usually apparent what name should be used for a new command.</span></span> <span data-ttu-id="d0390-134">예를 들어 컴퓨터 종료 명령은 **Stop-Computer**일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-134">For example, a computer shutdown command might be **Stop-Computer**.</span></span> <span data-ttu-id="d0390-135">네트워크에 있는 모든 컴퓨터를 표시하는 명령은 **Get-Computer**일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-135">A command that lists all computers on a network might be **Get-Computer**.</span></span> <span data-ttu-id="d0390-136">시스템 날짜를 가져오는 명령은 **Get-Date**입니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-136">The command that gets the system date is **Get-Date**.</span></span>

<span data-ttu-id="d0390-137">**Get-Command**의 **-Verb** 매개 변수를 사용하여 특정 동사를 포함하는 모든 명령을 표시할 수 있습니다. **Get-Command**는 다음 섹션에서 자세히 설명하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-137">You can list all commands that include a particular verb with the **-Verb** parameter for **Get-Command** (We will discuss **Get-Command** in detail in the next section).</span></span> <span data-ttu-id="d0390-138">예를 들어 **Get** 동사를 사용하는 모든 cmdlet을 보려면 다음과 같이 입력합니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-138">For example, to see all cmdlets that use the verb **Get**, type:</span></span>

```
PS> Get-Command -Verb Get
CommandType     Name                            Definition
-----------     ----                            ----------
Cmdlet          Get-Acl                         Get-Acl [[-Path] <String[]>]...
Cmdlet          Get-Alias                       Get-Alias [[-Name] <String[]...
Cmdlet          Get-AuthenticodeSignature       Get-AuthenticodeSignature [-...
Cmdlet          Get-ChildItem                   Get-ChildItem [[-Path] <Stri...
...
```

<span data-ttu-id="d0390-139">**-Noun** 매개 변수는 동일한 유형의 개체에 영향을 주는 명령 패밀리를 표시하므로 훨씬 더 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-139">The **-Noun** parameter is even more useful because it allows you to see a family of commands that affect the same type of object.</span></span> <span data-ttu-id="d0390-140">예를 들어 서비스 관리에 사용할 수 있는 명령을 보려는 경우 다음 명령을 입력합니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-140">For example, if you want to see which commands are available for managing services, type following command:</span></span>

```
PS> Get-Command -Noun Service
CommandType     Name                            Definition
-----------     ----                            ----------
Cmdlet          Get-Service                     Get-Service [[-Name] <String...
Cmdlet          New-Service                     New-Service [-Name] <String>...
Cmdlet          Restart-Service                 Restart-Service [-Name] <Str...
Cmdlet          Resume-Service                  Resume-Service [-Name] <Stri...
Cmdlet          Set-Service                     Set-Service [-Name] <String>...
Cmdlet          Start-Service                   Start-Service [-Name] <Strin...
Cmdlet          Stop-Service                    Stop-Service [-Name] <String...
Cmdlet          Suspend-Service                 Suspend-Service [-Name] <Str... 
...
```

<span data-ttu-id="d0390-141">명령이 동사-명사 명명 체계를 사용한다고 해서 반드시 cmdlet은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-141">A command is not necessarily a cmdlet, just because it has a verb-noun naming scheme.</span></span> <span data-ttu-id="d0390-142">cmdlet은 아니지만 동사-명사 이름을 가진 네이티브 Windows PowerShell 명령의 한 예로 콘솔 창을 지우는 명령인 Clear-Host가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-142">One example of a native Windows PowerShell command that is not a cmdlet but has a verb-noun name, is the command for clearing a console window, Clear-Host.</span></span> <span data-ttu-id="d0390-143">다음과 같이 Get-Command를 실행하면 알 수 있듯이 Clear-Host 명령은 실제로 내부 함수입니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-143">The Clear-Host command is actually an internal function, as you can see if you run Get-Command against it:</span></span>

```
PS> Get-Command -Name Clear-Host

CommandType     Name                            Definition
-----------     ----                            ----------
Function        Clear-Host                      $spaceType = [System.Managem...
```

### <a name="cmdlets-use-standard-parameters"></a><span data-ttu-id="d0390-144">표준 매개 변수 사용</span><span class="sxs-lookup"><span data-stu-id="d0390-144">Cmdlets Use Standard Parameters</span></span>
<span data-ttu-id="d0390-145">앞에서 설명한 대로 기존 명령줄 인터페이스에서 사용되는 명령에는 일반적으로 일관된 매개 변수 이름이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-145">As noted earlier, commands used in traditional command-line interfaces do not generally have consistent parameter names.</span></span> <span data-ttu-id="d0390-146">매개 변수에 이름이 없는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-146">Sometimes parameters do not have names at all.</span></span> <span data-ttu-id="d0390-147">이름이 있어도 단일 문자나 약어로 되어 있어 신속하게 입력할 수는 있지만 새로운 사용자가 쉽게 이해하기 힘듭니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-147">When they do, they are often single-character or abbreviated words that can be typed rapidly but are not easily understood by new users.</span></span>

<span data-ttu-id="d0390-148">대부분의 다른 기존 명령줄 인터페이스와 달리 Windows PowerShell은 매개 변수를 직접 처리하며, 매개 변수에 대한 이러한 직접 액세스와 함께 개발자 지침을 사용하여 매개 변수 이름을 표준화합니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-148">Unlike most other traditional command-line interfaces, Windows PowerShell processes parameters directly, and it uses this direct access to the parameters along with developer guidance to standardize parameter names.</span></span> <span data-ttu-id="d0390-149">이렇게 해도 모든 cmdlet이 항상 표준 이름을 사용하는 것은 아니지만 표준화를 촉진합니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-149">Although this does not guarantee that every cmdlet will always conform to the standards, it does encourage it.</span></span>

> [!NOTE]
> <span data-ttu-id="d0390-150">매개 변수 이름을 사용할 때는 항상 '-'이 앞에 추가되므로 Windows PowerShell이 명확하게 매개 변수로 식별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-150">Parameter names always have a '-' prepended to them when you use them, to allow Windows PowerShell to clearly identify them as parameters.</span></span> <span data-ttu-id="d0390-151">**Get-Command -Name Clear-Host** 예제에서 매개 변수 이름은 **Name**이지만 -**Name**으로 입력됩니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-151">In the **Get-Command -Name Clear-Host** example, the parameter's name is **Name**, but it is entered as -**Name**.</span></span>

<span data-ttu-id="d0390-152">다음은 표준 매개 변수 이름 및 사용법의 몇 가지 일반적인 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-152">Here are some of the general characteristics of the standard parameter names and usages.</span></span>

#### <a name="the-help-parameter-"></a><span data-ttu-id="d0390-153">도움말 매개 변수(?)</span><span class="sxs-lookup"><span data-stu-id="d0390-153">The Help Parameter (?)</span></span>
<span data-ttu-id="d0390-154">**-?**</span><span class="sxs-lookup"><span data-stu-id="d0390-154">When you specify the **-?**</span></span> <span data-ttu-id="d0390-155">매개 변수를 cmdlet에 지정하면 cmdlet이 실행되는 대신</span><span class="sxs-lookup"><span data-stu-id="d0390-155">parameter to any cmdlet, the cmdlet is not executed.</span></span> <span data-ttu-id="d0390-156">cmdlet에 대한 도움말이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-156">Instead, Windows PowerShell displays help for the cmdlet.</span></span>

#### <a name="common-parameters"></a><span data-ttu-id="d0390-157">일반 매개 변수</span><span class="sxs-lookup"><span data-stu-id="d0390-157">Common Parameters</span></span>
<span data-ttu-id="d0390-158">Windows PowerShell에는 *일반 매개 변수*라고 알려진 여러 매개 변수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-158">Windows PowerShell has several parameters known as *common parameters*.</span></span> <span data-ttu-id="d0390-159">이러한 매개 변수는 Windows PowerShell 엔진에 의해 제어되므로 cmdlet에서 구현할 때마다 항상 동일한 방식으로 동작합니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-159">Because these parameters are controlled by the Windows PowerShell engine, whenever they are implemented by a cmdlet, they will always behave the same way.</span></span> <span data-ttu-id="d0390-160">일반 매개 변수로는 **WhatIf**, **Confirm**, **Verbose**, **Debug**, **Warn**, **ErrorAction**, **ErrorVariable**, **OutVariable** 및 **OutBuffer**가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-160">The common parameters are **WhatIf**, **Confirm**, **Verbose**, **Debug**, **Warn**, **ErrorAction**, **ErrorVariable**, **OutVariable**, and **OutBuffer**.</span></span>

#### <a name="suggested-parameters"></a><span data-ttu-id="d0390-161">권장 매개 변수</span><span class="sxs-lookup"><span data-stu-id="d0390-161">Suggested Parameters</span></span>
<span data-ttu-id="d0390-162">Windows PowerShell 핵심 cmdlet은 유사한 매개 변수에 표준 이름을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-162">The Windows PowerShell core cmdlets use standard names for similar parameters.</span></span> <span data-ttu-id="d0390-163">매개 변수 이름을 반드시 사용해야 하는 것은 아니지만 Windows PowerShell에는 표준 이름 사용을 권장하는 명시적 지침이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-163">Although the use of parameter names is not enforced, there is explicit guidance for usage to encourage standardization.</span></span>

<span data-ttu-id="d0390-164">예를 들어 이 지침에서는 Server, Host, System, Node 또는 기타 일반적인 대체 단어가 아니라 **ComputerName**과 같이 컴퓨터를 이름으로 참조하는 매개 변수 이름을 권장합니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-164">For example, the guidance recommends naming a parameter that refers to a computer by name as **ComputerName**, rather than Server, Host, System, Node, or other common alternative words.</span></span> <span data-ttu-id="d0390-165">이러한 권장 매개 변수 이름으로는 **Force**, **Exclude**, **Include**, **PassThru**, **Path** 및 **CaseSensitive**가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0390-165">Among the important suggested parameter names are **Force**, **Exclude**, **Include**, **PassThru**, **Path**, and **CaseSensitive**.</span></span>

